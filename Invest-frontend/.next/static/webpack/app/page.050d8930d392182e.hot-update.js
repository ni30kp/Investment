"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/components/OverlapAnalysis.tsx":
/*!********************************************!*\
  !*** ./app/components/OverlapAnalysis.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ OverlapAnalysis; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction OverlapAnalysis(param) {\n    let { funds = [\n        {\n            id: \"1\",\n            name: \"Axis Bluechip Fund\",\n            color: \"#FFD700\"\n        },\n        {\n            id: \"2\",\n            name: \"HDFC Top 100 Fund\",\n            color: \"#4169E1\"\n        },\n        {\n            id: \"3\",\n            name: \"ICICI Prudential Bluechip Fund\",\n            color: \"#32CD32\"\n        },\n        {\n            id: \"4\",\n            name: \"SBI Bluechip Fund\",\n            color: \"#FF6347\"\n        }\n    ], commonStocks = [\n        \"HDFC LTD.\",\n        \"RIL\",\n        \"INFY\",\n        \"TCS\",\n        \"HDFCBANK\",\n        \"BHARTIARTL\"\n    ], overlapPairs = [] } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [canvasSize, setCanvasSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: 0\n    });\n    // Handle resize\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const handleResize = ()=>{\n            if (containerRef.current) {\n                setCanvasSize({\n                    width: containerRef.current.offsetWidth,\n                    height: 500 // Increased height to accommodate more funds\n                });\n            }\n        };\n        // Initial size\n        handleResize();\n        // Add resize listener\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>window.removeEventListener(\"resize\", handleResize);\n    }, []);\n    // Draw the visualization when canvas size changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!canvasRef.current || canvasSize.width === 0) return;\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Set canvas dimensions with device pixel ratio for sharper rendering\n        const dpr = window.devicePixelRatio || 1;\n        canvas.width = canvasSize.width * dpr;\n        canvas.height = canvasSize.height * dpr;\n        // Scale all drawing operations\n        ctx.scale(dpr, dpr);\n        // Set display size\n        canvas.style.width = \"\".concat(canvasSize.width, \"px\");\n        canvas.style.height = \"\".concat(canvasSize.height, \"px\");\n        // Clear canvas\n        ctx.clearRect(0, 0, canvasSize.width, canvasSize.height);\n        // Draw the overlap visualization\n        drawOverlapVisualization(ctx, canvasSize.width, canvasSize.height, funds, commonStocks, overlapPairs);\n    }, [\n        funds,\n        commonStocks,\n        overlapPairs,\n        canvasSize\n    ]);\n    // Function to draw the overlap visualization\n    const drawOverlapVisualization = (ctx, width, height, funds, commonStocks, overlapPairs)=>{\n        // Background for the visualization area (dark gray)\n        ctx.fillStyle = \"#1a1a1a\";\n        ctx.fillRect(0, 0, width, height);\n        // Draw funds on the left side\n        const fundBoxHeight = 50; // Reduced height for each fund box\n        const fundBoxWidth = 180;\n        const fundSpacing = 30; // Reduced spacing between funds\n        const totalFundsHeight = funds.length * fundBoxHeight + (funds.length - 1) * fundSpacing;\n        let fundStartY = (height - totalFundsHeight) / 2;\n        const fundPositions = {};\n        funds.forEach((fund, index)=>{\n            const y = fundStartY + index * (fundBoxHeight + fundSpacing);\n            // Store position for later use\n            fundPositions[fund.id] = {\n                x: 50,\n                y,\n                width: fundBoxWidth,\n                height: fundBoxHeight\n            };\n            // Draw fund box\n            ctx.fillStyle = \"#2a2a2a\";\n            ctx.beginPath();\n            ctx.roundRect(50, y, fundBoxWidth, fundBoxHeight, 8);\n            ctx.fill();\n            // Draw colored indicator bar - now on the right side of the fund box\n            ctx.fillStyle = fund.color;\n            ctx.fillRect(fundBoxWidth + 55, y, 5, fundBoxHeight);\n            // Draw fund name\n            ctx.fillStyle = \"#FFFFFF\";\n            ctx.font = \"12px Arial\";\n            ctx.textAlign = \"center\";\n            // Improved text wrapping to ensure text stays within the fund box\n            const maxWidth = fundBoxWidth - 20; // Leave some padding\n            const words = fund.name.split(\" \");\n            let lines = [];\n            let currentLine = words[0];\n            // Create lines that fit within the box width\n            for(let i = 1; i < words.length; i++){\n                const testLine = currentLine + \" \" + words[i];\n                const metrics = ctx.measureText(testLine);\n                if (metrics.width > maxWidth) {\n                    lines.push(currentLine);\n                    currentLine = words[i];\n                } else {\n                    currentLine = testLine;\n                }\n            }\n            lines.push(currentLine); // Add the last line\n            // Calculate vertical position for text\n            const lineHeight = 16;\n            const totalTextHeight = lines.length * lineHeight;\n            let textY = y + (fundBoxHeight - totalTextHeight) / 2 + lineHeight;\n            // Draw each line centered in the box\n            lines.forEach((line)=>{\n                ctx.fillText(line, fundBoxWidth / 2 + 50, textY);\n                textY += lineHeight;\n            });\n        });\n        // Draw stocks on the right side\n        const stockBoxHeight = 30;\n        const stockSpacing = 20;\n        const totalStocksHeight = commonStocks.length * stockBoxHeight + (commonStocks.length - 1) * stockSpacing;\n        let stockStartY = (height - totalStocksHeight) / 2;\n        const stockPositions = {};\n        commonStocks.forEach((stock, index)=>{\n            const y = stockStartY + index * (stockBoxHeight + stockSpacing);\n            // Store position for later use\n            stockPositions[stock] = {\n                x: width - 120,\n                y: y + stockBoxHeight / 2\n            };\n            // Draw stock label\n            ctx.fillStyle = \"#FFFFFF\";\n            ctx.font = \"14px Arial\";\n            ctx.textAlign = \"right\";\n            ctx.fillText(stock, width - 20, y + stockBoxHeight / 2 + 4);\n            // Draw small square indicator for each stock\n            ctx.fillStyle = \"#FFFFFF\";\n            ctx.fillRect(width - 130, y + stockBoxHeight / 2 - 2, 4, 4);\n        });\n        // Draw connections between funds and stocks\n        ctx.lineWidth = 1.5;\n        // Create a map to track which stocks are common between which funds\n        const fundStockMap = {};\n        // Initialize the map for each fund\n        funds.forEach((fund)=>{\n            fundStockMap[fund.id] = new Set();\n        });\n        // Populate the map based on overlap pairs\n        overlapPairs.forEach((pair)=>{\n            if (pair.data && pair.data.commonStocks) {\n                const fund1Id = pair.fund1.toString();\n                const fund2Id = pair.fund2.toString();\n                pair.data.commonStocks.forEach((stock)=>{\n                    if (fundStockMap[fund1Id]) fundStockMap[fund1Id].add(stock);\n                    if (fundStockMap[fund2Id]) fundStockMap[fund2Id].add(stock);\n                });\n            }\n        });\n        // For each fund, connect to its common stocks\n        funds.forEach((fund)=>{\n            const fundPos = fundPositions[fund.id];\n            const fundCenterY = fundPos.y + fundPos.height / 2;\n            const fundEndX = fundPos.x + fundPos.width + 5; // Start from the right edge of the fund box\n            // Get the stocks for this fund\n            const stocksForFund = fundStockMap[fund.id] || new Set();\n            // Draw connections only to stocks that are common for this fund\n            commonStocks.forEach((stock)=>{\n                if (stocksForFund.has(stock)) {\n                    const stockPos = stockPositions[stock];\n                    // Create gradient for the curve\n                    const gradient = ctx.createLinearGradient(fundEndX, fundCenterY, stockPos.x, stockPos.y);\n                    gradient.addColorStop(0, fund.color + \"80\"); // 50% opacity at start\n                    gradient.addColorStop(1, fund.color + \"40\"); // 25% opacity at end\n                    ctx.strokeStyle = gradient;\n                    // Draw the curve\n                    ctx.beginPath();\n                    ctx.moveTo(fundEndX, fundCenterY);\n                    // Control points for the bezier curve\n                    const cp1x = fundEndX + (stockPos.x - fundEndX) * 0.4;\n                    const cp1y = fundCenterY;\n                    const cp2x = fundEndX + (stockPos.x - fundEndX) * 0.6;\n                    const cp2y = stockPos.y;\n                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, stockPos.x, stockPos.y);\n                    ctx.stroke();\n                }\n            });\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"relative h-[500px] w-full\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            ref: canvasRef,\n            style: {\n                width: \"100%\",\n                height: \"100%\",\n                position: \"absolute\",\n                top: 0,\n                left: 0\n            }\n        }, void 0, false, {\n            fileName: \"/Users/nitish/Desktop/InvestWelth/Invest-frontend/app/components/OverlapAnalysis.tsx\",\n            lineNumber: 269,\n            columnNumber: 13\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/nitish/Desktop/InvestWelth/Invest-frontend/app/components/OverlapAnalysis.tsx\",\n        lineNumber: 268,\n        columnNumber: 9\n    }, this);\n}\n_s(OverlapAnalysis, \"wtHXhGCAht3/oLYxq4+cPYMbEKU=\");\n_c = OverlapAnalysis;\nvar _c;\n$RefreshReg$(_c, \"OverlapAnalysis\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL092ZXJsYXBBbmFseXNpcy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRW9EO0FBMkJyQyxTQUFTRyxnQkFBZ0IsS0FnQmpCO1FBaEJpQixFQUNwQ0MsUUFBUTtRQUNKO1lBQUVDLElBQUk7WUFBS0MsTUFBTTtZQUFzQkMsT0FBTztRQUFVO1FBQ3hEO1lBQUVGLElBQUk7WUFBS0MsTUFBTTtZQUFxQkMsT0FBTztRQUFVO1FBQ3ZEO1lBQUVGLElBQUk7WUFBS0MsTUFBTTtZQUFrQ0MsT0FBTztRQUFVO1FBQ3BFO1lBQUVGLElBQUk7WUFBS0MsTUFBTTtZQUFxQkMsT0FBTztRQUFVO0tBQzFELEVBQ0RDLGVBQWU7UUFDWDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSCxFQUNEQyxlQUFlLEVBQUUsRUFDRSxHQWhCaUI7O0lBaUJwQyxNQUFNQyxZQUFZVCw2Q0FBTUEsQ0FBb0I7SUFDNUMsTUFBTVUsZUFBZVYsNkNBQU1BLENBQWlCO0lBQzVDLE1BQU0sQ0FBQ1csWUFBWUMsY0FBYyxHQUFHWCwrQ0FBUUEsQ0FBQztRQUFFWSxPQUFPO1FBQUdDLFFBQVE7SUFBRTtJQUVuRSxnQkFBZ0I7SUFDaEJmLGdEQUFTQSxDQUFDO1FBQ04sTUFBTWdCLGVBQWU7WUFDakIsSUFBSUwsYUFBYU0sT0FBTyxFQUFFO2dCQUN0QkosY0FBYztvQkFDVkMsT0FBT0gsYUFBYU0sT0FBTyxDQUFDQyxXQUFXO29CQUN2Q0gsUUFBUSxJQUFJLDZDQUE2QztnQkFDN0Q7WUFDSjtRQUNKO1FBRUEsZUFBZTtRQUNmQztRQUVBLHNCQUFzQjtRQUN0QkcsT0FBT0MsZ0JBQWdCLENBQUMsVUFBVUo7UUFDbEMsT0FBTyxJQUFNRyxPQUFPRSxtQkFBbUIsQ0FBQyxVQUFVTDtJQUN0RCxHQUFHLEVBQUU7SUFFTCxrREFBa0Q7SUFDbERoQixnREFBU0EsQ0FBQztRQUNOLElBQUksQ0FBQ1UsVUFBVU8sT0FBTyxJQUFJTCxXQUFX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O2dCQUNIZCxPQUFPO2dCQUNQQyxRQUFRO2dCQUNSdUYsVUFBVTtnQkFDVkMsS0FBSztnQkFDTEMsTUFBTTtZQUNWOzs7Ozs7Ozs7OztBQUloQjtHQTNQd0JyRztLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9PdmVybGFwQW5hbHlzaXMudHN4P2ZmNDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmludGVyZmFjZSBGdW5kIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBjb2xvcjogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgT3ZlcmxhcERhdGEge1xuICAgIGZ1bmRzOiB7IGlkOiBudW1iZXI7IG5hbWU6IHN0cmluZyB9W107XG4gICAgc3RvY2tzT3ZlcmxhcDogbnVtYmVyO1xuICAgIGF2ZXJhZ2VPdmVybGFwUGVyY2VudGFnZTogbnVtYmVyO1xuICAgIGNvbW1vblN0b2Nrczogc3RyaW5nW107XG59XG5cbmludGVyZmFjZSBGdW5kUGFpciB7XG4gICAgZnVuZDE6IG51bWJlcjtcbiAgICBmdW5kMjogbnVtYmVyO1xuICAgIGRhdGE6IE92ZXJsYXBEYXRhO1xufVxuXG5pbnRlcmZhY2UgT3ZlcmxhcEFuYWx5c2lzUHJvcHMge1xuICAgIGZ1bmRzPzogRnVuZFtdO1xuICAgIGNvbW1vblN0b2Nrcz86IHN0cmluZ1tdO1xuICAgIG92ZXJsYXBQYWlycz86IEZ1bmRQYWlyW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE92ZXJsYXBBbmFseXNpcyh7XG4gICAgZnVuZHMgPSBbXG4gICAgICAgIHsgaWQ6ICcxJywgbmFtZTogJ0F4aXMgQmx1ZWNoaXAgRnVuZCcsIGNvbG9yOiAnI0ZGRDcwMCcgfSxcbiAgICAgICAgeyBpZDogJzInLCBuYW1lOiAnSERGQyBUb3AgMTAwIEZ1bmQnLCBjb2xvcjogJyM0MTY5RTEnIH0sXG4gICAgICAgIHsgaWQ6ICczJywgbmFtZTogJ0lDSUNJIFBydWRlbnRpYWwgQmx1ZWNoaXAgRnVuZCcsIGNvbG9yOiAnIzMyQ0QzMicgfSxcbiAgICAgICAgeyBpZDogJzQnLCBuYW1lOiAnU0JJIEJsdWVjaGlwIEZ1bmQnLCBjb2xvcjogJyNGRjYzNDcnIH1cbiAgICBdLFxuICAgIGNvbW1vblN0b2NrcyA9IFtcbiAgICAgICAgJ0hERkMgTFRELicsXG4gICAgICAgICdSSUwnLFxuICAgICAgICAnSU5GWScsXG4gICAgICAgICdUQ1MnLFxuICAgICAgICAnSERGQ0JBTksnLFxuICAgICAgICAnQkhBUlRJQVJUTCdcbiAgICBdLFxuICAgIG92ZXJsYXBQYWlycyA9IFtdXG59OiBPdmVybGFwQW5hbHlzaXNQcm9wcykge1xuICAgIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XG4gICAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgICBjb25zdCBbY2FudmFzU2l6ZSwgc2V0Q2FudmFzU2l6ZV0gPSB1c2VTdGF0ZSh7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG5cbiAgICAvLyBIYW5kbGUgcmVzaXplXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0Q2FudmFzU2l6ZSh7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb250YWluZXJSZWYuY3VycmVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA1MDAgLy8gSW5jcmVhc2VkIGhlaWdodCB0byBhY2NvbW1vZGF0ZSBtb3JlIGZ1bmRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW5pdGlhbCBzaXplXG4gICAgICAgIGhhbmRsZVJlc2l6ZSgpO1xuXG4gICAgICAgIC8vIEFkZCByZXNpemUgbGlzdGVuZXJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBEcmF3IHRoZSB2aXN1YWxpemF0aW9uIHdoZW4gY2FudmFzIHNpemUgY2hhbmdlc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQgfHwgY2FudmFzU2l6ZS53aWR0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKCFjdHgpIHJldHVybjtcblxuICAgICAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnMgd2l0aCBkZXZpY2UgcGl4ZWwgcmF0aW8gZm9yIHNoYXJwZXIgcmVuZGVyaW5nXG4gICAgICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1NpemUud2lkdGggKiBkcHI7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNTaXplLmhlaWdodCAqIGRwcjtcblxuICAgICAgICAvLyBTY2FsZSBhbGwgZHJhd2luZyBvcGVyYXRpb25zXG4gICAgICAgIGN0eC5zY2FsZShkcHIsIGRwcik7XG5cbiAgICAgICAgLy8gU2V0IGRpc3BsYXkgc2l6ZVxuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjYW52YXNTaXplLndpZHRofXB4YDtcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NhbnZhc1NpemUuaGVpZ2h0fXB4YDtcblxuICAgICAgICAvLyBDbGVhciBjYW52YXNcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXNTaXplLndpZHRoLCBjYW52YXNTaXplLmhlaWdodCk7XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgb3ZlcmxhcCB2aXN1YWxpemF0aW9uXG4gICAgICAgIGRyYXdPdmVybGFwVmlzdWFsaXphdGlvbihjdHgsIGNhbnZhc1NpemUud2lkdGgsIGNhbnZhc1NpemUuaGVpZ2h0LCBmdW5kcywgY29tbW9uU3RvY2tzLCBvdmVybGFwUGFpcnMpO1xuICAgIH0sIFtmdW5kcywgY29tbW9uU3RvY2tzLCBvdmVybGFwUGFpcnMsIGNhbnZhc1NpemVdKTtcblxuICAgIC8vIEZ1bmN0aW9uIHRvIGRyYXcgdGhlIG92ZXJsYXAgdmlzdWFsaXphdGlvblxuICAgIGNvbnN0IGRyYXdPdmVybGFwVmlzdWFsaXphdGlvbiA9IChcbiAgICAgICAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gICAgICAgIHdpZHRoOiBudW1iZXIsXG4gICAgICAgIGhlaWdodDogbnVtYmVyLFxuICAgICAgICBmdW5kczogRnVuZFtdLFxuICAgICAgICBjb21tb25TdG9ja3M6IHN0cmluZ1tdLFxuICAgICAgICBvdmVybGFwUGFpcnM6IEZ1bmRQYWlyW11cbiAgICApID0+IHtcbiAgICAgICAgLy8gQmFja2dyb3VuZCBmb3IgdGhlIHZpc3VhbGl6YXRpb24gYXJlYSAoZGFyayBncmF5KVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyMxYTFhMWEnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgLy8gRHJhdyBmdW5kcyBvbiB0aGUgbGVmdCBzaWRlXG4gICAgICAgIGNvbnN0IGZ1bmRCb3hIZWlnaHQgPSA1MDsgLy8gUmVkdWNlZCBoZWlnaHQgZm9yIGVhY2ggZnVuZCBib3hcbiAgICAgICAgY29uc3QgZnVuZEJveFdpZHRoID0gMTgwO1xuICAgICAgICBjb25zdCBmdW5kU3BhY2luZyA9IDMwOyAvLyBSZWR1Y2VkIHNwYWNpbmcgYmV0d2VlbiBmdW5kc1xuICAgICAgICBjb25zdCB0b3RhbEZ1bmRzSGVpZ2h0ID0gZnVuZHMubGVuZ3RoICogZnVuZEJveEhlaWdodCArIChmdW5kcy5sZW5ndGggLSAxKSAqIGZ1bmRTcGFjaW5nO1xuICAgICAgICBsZXQgZnVuZFN0YXJ0WSA9IChoZWlnaHQgLSB0b3RhbEZ1bmRzSGVpZ2h0KSAvIDI7XG5cbiAgICAgICAgY29uc3QgZnVuZFBvc2l0aW9uczogeyBba2V5OiBzdHJpbmddOiB7IHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9IH0gPSB7fTtcblxuICAgICAgICBmdW5kcy5mb3JFYWNoKChmdW5kLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeSA9IGZ1bmRTdGFydFkgKyBpbmRleCAqIChmdW5kQm94SGVpZ2h0ICsgZnVuZFNwYWNpbmcpO1xuXG4gICAgICAgICAgICAvLyBTdG9yZSBwb3NpdGlvbiBmb3IgbGF0ZXIgdXNlXG4gICAgICAgICAgICBmdW5kUG9zaXRpb25zW2Z1bmQuaWRdID0ge1xuICAgICAgICAgICAgICAgIHg6IDUwLCAvLyBNb3ZlZCBmdXJ0aGVyIGxlZnRcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBmdW5kQm94V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBmdW5kQm94SGVpZ2h0XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBEcmF3IGZ1bmQgYm94XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyMyYTJhMmEnO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJvdW5kUmVjdCg1MCwgeSwgZnVuZEJveFdpZHRoLCBmdW5kQm94SGVpZ2h0LCA4KTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgY29sb3JlZCBpbmRpY2F0b3IgYmFyIC0gbm93IG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBmdW5kIGJveFxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZ1bmQuY29sb3I7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoZnVuZEJveFdpZHRoICsgNTUsIHksIDUsIGZ1bmRCb3hIZWlnaHQpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IGZ1bmQgbmFtZVxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjRkZGRkZGJztcbiAgICAgICAgICAgIGN0eC5mb250ID0gJzEycHggQXJpYWwnO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXG4gICAgICAgICAgICAvLyBJbXByb3ZlZCB0ZXh0IHdyYXBwaW5nIHRvIGVuc3VyZSB0ZXh0IHN0YXlzIHdpdGhpbiB0aGUgZnVuZCBib3hcbiAgICAgICAgICAgIGNvbnN0IG1heFdpZHRoID0gZnVuZEJveFdpZHRoIC0gMjA7IC8vIExlYXZlIHNvbWUgcGFkZGluZ1xuICAgICAgICAgICAgY29uc3Qgd29yZHMgPSBmdW5kLm5hbWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRMaW5lID0gd29yZHNbMF07XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBsaW5lcyB0aGF0IGZpdCB3aXRoaW4gdGhlIGJveCB3aWR0aFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RMaW5lID0gY3VycmVudExpbmUgKyAnICcgKyB3b3Jkc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KHRlc3RMaW5lKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobWV0cmljcy53aWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZSA9IHdvcmRzW2ldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gdGVzdExpbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7IC8vIEFkZCB0aGUgbGFzdCBsaW5lXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB2ZXJ0aWNhbCBwb3NpdGlvbiBmb3IgdGV4dFxuICAgICAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IDE2O1xuICAgICAgICAgICAgY29uc3QgdG90YWxUZXh0SGVpZ2h0ID0gbGluZXMubGVuZ3RoICogbGluZUhlaWdodDtcbiAgICAgICAgICAgIGxldCB0ZXh0WSA9IHkgKyAoZnVuZEJveEhlaWdodCAtIHRvdGFsVGV4dEhlaWdodCkgLyAyICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRHJhdyBlYWNoIGxpbmUgY2VudGVyZWQgaW4gdGhlIGJveFxuICAgICAgICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobGluZSwgZnVuZEJveFdpZHRoIC8gMiArIDUwLCB0ZXh0WSk7XG4gICAgICAgICAgICAgICAgdGV4dFkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEcmF3IHN0b2NrcyBvbiB0aGUgcmlnaHQgc2lkZVxuICAgICAgICBjb25zdCBzdG9ja0JveEhlaWdodCA9IDMwO1xuICAgICAgICBjb25zdCBzdG9ja1NwYWNpbmcgPSAyMDtcbiAgICAgICAgY29uc3QgdG90YWxTdG9ja3NIZWlnaHQgPSBjb21tb25TdG9ja3MubGVuZ3RoICogc3RvY2tCb3hIZWlnaHQgKyAoY29tbW9uU3RvY2tzLmxlbmd0aCAtIDEpICogc3RvY2tTcGFjaW5nO1xuICAgICAgICBsZXQgc3RvY2tTdGFydFkgPSAoaGVpZ2h0IC0gdG90YWxTdG9ja3NIZWlnaHQpIC8gMjtcblxuICAgICAgICBjb25zdCBzdG9ja1Bvc2l0aW9uczogeyBba2V5OiBzdHJpbmddOiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH0gfSA9IHt9O1xuXG4gICAgICAgIGNvbW1vblN0b2Nrcy5mb3JFYWNoKChzdG9jaywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBzdG9ja1N0YXJ0WSArIGluZGV4ICogKHN0b2NrQm94SGVpZ2h0ICsgc3RvY2tTcGFjaW5nKTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgcG9zaXRpb24gZm9yIGxhdGVyIHVzZVxuICAgICAgICAgICAgc3RvY2tQb3NpdGlvbnNbc3RvY2tdID0ge1xuICAgICAgICAgICAgICAgIHg6IHdpZHRoIC0gMTIwLCAvLyBNb3ZlZCBmdXJ0aGVyIHJpZ2h0XG4gICAgICAgICAgICAgICAgeTogeSArIHN0b2NrQm94SGVpZ2h0IC8gMlxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gRHJhdyBzdG9jayBsYWJlbFxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjRkZGRkZGJztcbiAgICAgICAgICAgIGN0eC5mb250ID0gJzE0cHggQXJpYWwnO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoc3RvY2ssIHdpZHRoIC0gMjAsIHkgKyBzdG9ja0JveEhlaWdodCAvIDIgKyA0KTtcblxuICAgICAgICAgICAgLy8gRHJhdyBzbWFsbCBzcXVhcmUgaW5kaWNhdG9yIGZvciBlYWNoIHN0b2NrXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNGRkZGRkYnO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHdpZHRoIC0gMTMwLCB5ICsgc3RvY2tCb3hIZWlnaHQgLyAyIC0gMiwgNCwgNCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERyYXcgY29ubmVjdGlvbnMgYmV0d2VlbiBmdW5kcyBhbmQgc3RvY2tzXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxLjU7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbWFwIHRvIHRyYWNrIHdoaWNoIHN0b2NrcyBhcmUgY29tbW9uIGJldHdlZW4gd2hpY2ggZnVuZHNcbiAgICAgICAgY29uc3QgZnVuZFN0b2NrTWFwOiBSZWNvcmQ8c3RyaW5nLCBTZXQ8c3RyaW5nPj4gPSB7fTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBtYXAgZm9yIGVhY2ggZnVuZFxuICAgICAgICBmdW5kcy5mb3JFYWNoKGZ1bmQgPT4ge1xuICAgICAgICAgICAgZnVuZFN0b2NrTWFwW2Z1bmQuaWRdID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBtYXAgYmFzZWQgb24gb3ZlcmxhcCBwYWlyc1xuICAgICAgICBvdmVybGFwUGFpcnMuZm9yRWFjaChwYWlyID0+IHtcbiAgICAgICAgICAgIGlmIChwYWlyLmRhdGEgJiYgcGFpci5kYXRhLmNvbW1vblN0b2Nrcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bmQxSWQgPSBwYWlyLmZ1bmQxLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuZDJJZCA9IHBhaXIuZnVuZDIudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgIHBhaXIuZGF0YS5jb21tb25TdG9ja3MuZm9yRWFjaChzdG9jayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5kU3RvY2tNYXBbZnVuZDFJZF0pIGZ1bmRTdG9ja01hcFtmdW5kMUlkXS5hZGQoc3RvY2spO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuZFN0b2NrTWFwW2Z1bmQySWRdKSBmdW5kU3RvY2tNYXBbZnVuZDJJZF0uYWRkKHN0b2NrKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggZnVuZCwgY29ubmVjdCB0byBpdHMgY29tbW9uIHN0b2Nrc1xuICAgICAgICBmdW5kcy5mb3JFYWNoKChmdW5kKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmdW5kUG9zID0gZnVuZFBvc2l0aW9uc1tmdW5kLmlkXTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmRDZW50ZXJZID0gZnVuZFBvcy55ICsgZnVuZFBvcy5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgY29uc3QgZnVuZEVuZFggPSBmdW5kUG9zLnggKyBmdW5kUG9zLndpZHRoICsgNTsgLy8gU3RhcnQgZnJvbSB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgZnVuZCBib3hcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSBzdG9ja3MgZm9yIHRoaXMgZnVuZFxuICAgICAgICAgICAgY29uc3Qgc3RvY2tzRm9yRnVuZCA9IGZ1bmRTdG9ja01hcFtmdW5kLmlkXSB8fCBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgICAgICAgICAgLy8gRHJhdyBjb25uZWN0aW9ucyBvbmx5IHRvIHN0b2NrcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoaXMgZnVuZFxuICAgICAgICAgICAgY29tbW9uU3RvY2tzLmZvckVhY2goKHN0b2NrKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b2Nrc0ZvckZ1bmQuaGFzKHN0b2NrKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9ja1BvcyA9IHN0b2NrUG9zaXRpb25zW3N0b2NrXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZ3JhZGllbnQgZm9yIHRoZSBjdXJ2ZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChmdW5kRW5kWCwgZnVuZENlbnRlclksIHN0b2NrUG9zLngsIHN0b2NrUG9zLnkpO1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgZnVuZC5jb2xvciArICc4MCcpOyAvLyA1MCUgb3BhY2l0eSBhdCBzdGFydFxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgZnVuZC5jb2xvciArICc0MCcpOyAvLyAyNSUgb3BhY2l0eSBhdCBlbmRcblxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBncmFkaWVudDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBjdXJ2ZVxuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oZnVuZEVuZFgsIGZ1bmRDZW50ZXJZKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb250cm9sIHBvaW50cyBmb3IgdGhlIGJlemllciBjdXJ2ZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjcDF4ID0gZnVuZEVuZFggKyAoc3RvY2tQb3MueCAtIGZ1bmRFbmRYKSAqIDAuNDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3AxeSA9IGZ1bmRDZW50ZXJZO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjcDJ4ID0gZnVuZEVuZFggKyAoc3RvY2tQb3MueCAtIGZ1bmRFbmRYKSAqIDAuNjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3AyeSA9IHN0b2NrUG9zLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgc3RvY2tQb3MueCwgc3RvY2tQb3MueSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgcmVmPXtjb250YWluZXJSZWZ9IGNsYXNzTmFtZT1cInJlbGF0aXZlIGgtWzUwMHB4XSB3LWZ1bGxcIj5cbiAgICAgICAgICAgIDxjYW52YXNcbiAgICAgICAgICAgICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufSAiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJPdmVybGFwQW5hbHlzaXMiLCJmdW5kcyIsImlkIiwibmFtZSIsImNvbG9yIiwiY29tbW9uU3RvY2tzIiwib3ZlcmxhcFBhaXJzIiwiY2FudmFzUmVmIiwiY29udGFpbmVyUmVmIiwiY2FudmFzU2l6ZSIsInNldENhbnZhc1NpemUiLCJ3aWR0aCIsImhlaWdodCIsImhhbmRsZVJlc2l6ZSIsImN1cnJlbnQiLCJvZmZzZXRXaWR0aCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImRwciIsImRldmljZVBpeGVsUmF0aW8iLCJzY2FsZSIsInN0eWxlIiwiY2xlYXJSZWN0IiwiZHJhd092ZXJsYXBWaXN1YWxpemF0aW9uIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJmdW5kQm94SGVpZ2h0IiwiZnVuZEJveFdpZHRoIiwiZnVuZFNwYWNpbmciLCJ0b3RhbEZ1bmRzSGVpZ2h0IiwibGVuZ3RoIiwiZnVuZFN0YXJ0WSIsImZ1bmRQb3NpdGlvbnMiLCJmb3JFYWNoIiwiZnVuZCIsImluZGV4IiwieSIsIngiLCJiZWdpblBhdGgiLCJyb3VuZFJlY3QiLCJmaWxsIiwiZm9udCIsInRleHRBbGlnbiIsIm1heFdpZHRoIiwid29yZHMiLCJzcGxpdCIsImxpbmVzIiwiY3VycmVudExpbmUiLCJpIiwidGVzdExpbmUiLCJtZXRyaWNzIiwibWVhc3VyZVRleHQiLCJwdXNoIiwibGluZUhlaWdodCIsInRvdGFsVGV4dEhlaWdodCIsInRleHRZIiwibGluZSIsImZpbGxUZXh0Iiwic3RvY2tCb3hIZWlnaHQiLCJzdG9ja1NwYWNpbmciLCJ0b3RhbFN0b2Nrc0hlaWdodCIsInN0b2NrU3RhcnRZIiwic3RvY2tQb3NpdGlvbnMiLCJzdG9jayIsImxpbmVXaWR0aCIsImZ1bmRTdG9ja01hcCIsIlNldCIsInBhaXIiLCJkYXRhIiwiZnVuZDFJZCIsImZ1bmQxIiwidG9TdHJpbmciLCJmdW5kMklkIiwiZnVuZDIiLCJhZGQiLCJmdW5kUG9zIiwiZnVuZENlbnRlclkiLCJmdW5kRW5kWCIsInN0b2Nrc0ZvckZ1bmQiLCJoYXMiLCJzdG9ja1BvcyIsImdyYWRpZW50IiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJhZGRDb2xvclN0b3AiLCJzdHJva2VTdHlsZSIsIm1vdmVUbyIsImNwMXgiLCJjcDF5IiwiY3AyeCIsImNwMnkiLCJiZXppZXJDdXJ2ZVRvIiwic3Ryb2tlIiwiZGl2IiwicmVmIiwiY2xhc3NOYW1lIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/OverlapAnalysis.tsx\n"));

/***/ })

});