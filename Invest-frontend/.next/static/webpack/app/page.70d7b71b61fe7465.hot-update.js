"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/components/OverlapAnalysis.tsx":
/*!********************************************!*\
  !*** ./app/components/OverlapAnalysis.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ OverlapAnalysis; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction OverlapAnalysis(param) {\n    let { funds = [\n        {\n            id: \"1\",\n            name: \"Axis Bluechip Fund\",\n            color: \"#FFD700\"\n        },\n        {\n            id: \"2\",\n            name: \"HDFC Top 100 Fund\",\n            color: \"#4169E1\"\n        },\n        {\n            id: \"3\",\n            name: \"ICICI Prudential Bluechip Fund\",\n            color: \"#32CD32\"\n        },\n        {\n            id: \"4\",\n            name: \"SBI Bluechip Fund\",\n            color: \"#FF6347\"\n        }\n    ], commonStocks = [\n        \"HDFC LTD.\",\n        \"RIL\",\n        \"INFY\",\n        \"TCS\",\n        \"HDFCBANK\",\n        \"BHARTIARTL\"\n    ], overlapPairs = [] } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [canvasSize, setCanvasSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: 0\n    });\n    // Handle resize\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const handleResize = ()=>{\n            if (containerRef.current) {\n                setCanvasSize({\n                    width: containerRef.current.offsetWidth,\n                    height: 500 // Increased height to accommodate more funds\n                });\n            }\n        };\n        // Initial size\n        handleResize();\n        // Add resize listener\n        window.addEventListener(\"resize\", handleResize);\n        return ()=>window.removeEventListener(\"resize\", handleResize);\n    }, []);\n    // Draw the visualization when canvas size changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!canvasRef.current || canvasSize.width === 0) return;\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Set canvas dimensions with device pixel ratio for sharper rendering\n        const dpr = window.devicePixelRatio || 1;\n        canvas.width = canvasSize.width * dpr;\n        canvas.height = canvasSize.height * dpr;\n        // Scale all drawing operations\n        ctx.scale(dpr, dpr);\n        // Set display size\n        canvas.style.width = \"\".concat(canvasSize.width, \"px\");\n        canvas.style.height = \"\".concat(canvasSize.height, \"px\");\n        // Clear canvas\n        ctx.clearRect(0, 0, canvasSize.width, canvasSize.height);\n        // Draw the overlap visualization\n        drawOverlapVisualization(ctx, canvasSize.width, canvasSize.height, funds, commonStocks, overlapPairs);\n    }, [\n        funds,\n        commonStocks,\n        overlapPairs,\n        canvasSize\n    ]);\n    // Function to draw the overlap visualization\n    const drawOverlapVisualization = (ctx, width, height, funds, commonStocks, overlapPairs)=>{\n        // Background for the visualization area (dark gray)\n        ctx.fillStyle = \"#1a1a1a\";\n        ctx.fillRect(0, 0, width, height);\n        // Draw funds on the left side\n        const fundBoxHeight = 50; // Reduced height for each fund box\n        const fundBoxWidth = 180;\n        const fundSpacing = 30; // Reduced spacing between funds\n        const totalFundsHeight = funds.length * fundBoxHeight + (funds.length - 1) * fundSpacing;\n        let fundStartY = (height - totalFundsHeight) / 2;\n        const fundPositions = {};\n        funds.forEach((fund, index)=>{\n            const y = fundStartY + index * (fundBoxHeight + fundSpacing);\n            // Store position for later use\n            fundPositions[fund.id] = {\n                x: 50,\n                y,\n                width: fundBoxWidth,\n                height: fundBoxHeight\n            };\n            // Draw fund box\n            ctx.fillStyle = \"#2a2a2a\";\n            ctx.beginPath();\n            ctx.roundRect(50, y, fundBoxWidth, fundBoxHeight, 8);\n            ctx.fill();\n            // Draw colored indicator bar - now on the right side of the fund box\n            ctx.fillStyle = fund.color;\n            ctx.fillRect(fundBoxWidth + 55, y, 5, fundBoxHeight);\n            // Draw fund name\n            ctx.fillStyle = \"#FFFFFF\";\n            ctx.font = \"12px Arial\";\n            ctx.textAlign = \"center\";\n            // Improved text wrapping to ensure text stays within the fund box\n            const maxWidth = fundBoxWidth - 20; // Leave some padding\n            const words = fund.name.split(\" \");\n            let lines = [];\n            let currentLine = words[0];\n            // Create lines that fit within the box width\n            for(let i = 1; i < words.length; i++){\n                const testLine = currentLine + \" \" + words[i];\n                const metrics = ctx.measureText(testLine);\n                if (metrics.width > maxWidth) {\n                    lines.push(currentLine);\n                    currentLine = words[i];\n                } else {\n                    currentLine = testLine;\n                }\n            }\n            lines.push(currentLine); // Add the last line\n            // Calculate vertical position for text\n            const lineHeight = 16;\n            const totalTextHeight = lines.length * lineHeight;\n            let textY = y + (fundBoxHeight - totalTextHeight) / 2 + lineHeight;\n            // Draw each line centered in the box\n            lines.forEach((line)=>{\n                ctx.fillText(line, fundBoxWidth / 2 + 50, textY);\n                textY += lineHeight;\n            });\n        });\n        // Draw stocks on the right side\n        const stockBoxHeight = 30;\n        const stockSpacing = 20;\n        const totalStocksHeight = commonStocks.length * stockBoxHeight + (commonStocks.length - 1) * stockSpacing;\n        let stockStartY = (height - totalStocksHeight) / 2;\n        const stockPositions = {};\n        commonStocks.forEach((stock, index)=>{\n            const y = stockStartY + index * (stockBoxHeight + stockSpacing);\n            // Store position for later use\n            stockPositions[stock] = {\n                x: width - 120,\n                y: y + stockBoxHeight / 2\n            };\n            // Draw stock label\n            ctx.fillStyle = \"#FFFFFF\";\n            ctx.font = \"14px Arial\";\n            ctx.textAlign = \"right\";\n            ctx.fillText(stock, width - 20, y + stockBoxHeight / 2 + 4);\n            // Draw small square indicator for each stock\n            ctx.fillStyle = \"#FFFFFF\";\n            ctx.fillRect(width - 130, y + stockBoxHeight / 2 - 2, 4, 4);\n        });\n        // Draw connections between funds and stocks\n        ctx.lineWidth = 1.5;\n        // Create a map to track which stocks are common between which funds\n        const fundStockMap = {};\n        // Initialize the map for each fund\n        funds.forEach((fund)=>{\n            fundStockMap[fund.id] = new Set();\n        });\n        // Populate the map based on overlap pairs\n        overlapPairs.forEach((pair)=>{\n            if (pair.data && pair.data.commonStocks) {\n                const fund1Id = pair.fund1.toString();\n                const fund2Id = pair.fund2.toString();\n                pair.data.commonStocks.forEach((stock)=>{\n                    if (fundStockMap[fund1Id]) fundStockMap[fund1Id].add(stock);\n                    if (fundStockMap[fund2Id]) fundStockMap[fund2Id].add(stock);\n                });\n            }\n        });\n        // For each fund, connect to its common stocks\n        funds.forEach((fund)=>{\n            const fundPos = fundPositions[fund.id];\n            const fundCenterY = fundPos.y + fundPos.height / 2;\n            const fundEndX = fundPos.x + fundPos.width + 5; // Start from the right edge of the fund box\n            // Get the stocks for this fund\n            const stocksForFund = fundStockMap[fund.id] || new Set();\n            // Draw connections only to stocks that are common for this fund\n            commonStocks.forEach((stock)=>{\n                if (stocksForFund.has(stock)) {\n                    const stockPos = stockPositions[stock];\n                    // Create gradient for the curve\n                    const gradient = ctx.createLinearGradient(fundEndX, fundCenterY, stockPos.x, stockPos.y);\n                    gradient.addColorStop(0, fund.color + \"80\"); // 50% opacity at start\n                    gradient.addColorStop(1, fund.color + \"40\"); // 25% opacity at end\n                    ctx.strokeStyle = gradient;\n                    // Draw the curve\n                    ctx.beginPath();\n                    ctx.moveTo(fundEndX, fundCenterY);\n                    // Control points for the bezier curve\n                    const cp1x = fundEndX + (stockPos.x - fundEndX) * 0.4;\n                    const cp1y = fundCenterY;\n                    const cp2x = fundEndX + (stockPos.x - fundEndX) * 0.6;\n                    const cp2y = stockPos.y;\n                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, stockPos.x, stockPos.y);\n                    ctx.stroke();\n                }\n            });\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"relative h-[500px] w-full\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n            ref: canvasRef,\n            style: {\n                width: \"100%\",\n                height: \"100%\",\n                position: \"absolute\",\n                top: 0,\n                left: 0\n            }\n        }, void 0, false, {\n            fileName: \"/Users/nitish/Desktop/InvestWelth/Invest-frontend/app/components/OverlapAnalysis.tsx\",\n            lineNumber: 269,\n            columnNumber: 13\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/nitish/Desktop/InvestWelth/Invest-frontend/app/components/OverlapAnalysis.tsx\",\n        lineNumber: 268,\n        columnNumber: 9\n    }, this);\n}\n_s(OverlapAnalysis, \"wtHXhGCAht3/oLYxq4+cPYMbEKU=\");\n_c = OverlapAnalysis;\nvar _c;\n$RefreshReg$(_c, \"OverlapAnalysis\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL092ZXJsYXBBbmFseXNpcy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRW9EO0FBMkJyQyxTQUFTRyxnQkFBZ0IsS0FnQmpCO1FBaEJpQixFQUNwQ0MsUUFBUTtRQUNKO1lBQUVDLElBQUk7WUFBS0MsTUFBTTtZQUFzQkMsT0FBTztRQUFVO1FBQ3hEO1lBQUVGLElBQUk7WUFBS0MsTUFBTTtZQUFxQkMsT0FBTztRQUFVO1FBQ3ZEO1lBQUVGLElBQUk7WUFBS0MsTUFBTTtZQUFrQ0MsT0FBTztRQUFVO1FBQ3BFO1lBQUVGLElBQUk7WUFBS0MsTUFBTTtZQUFxQkMsT0FBTztRQUFVO0tBQzFELEVBQ0RDLGVBQWU7UUFDWDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSCxFQUNEQyxlQUFlLEVBQUUsRUFDRSxHQWhCaUI7O0lBaUJwQyxNQUFNQyxZQUFZVCw2Q0FBTUEsQ0FBb0I7SUFDNUMsTUFBTVUsZUFBZVYsNkNBQU1BLENBQWlCO0lBQzVDLE1BQU0sQ0FBQ1csWUFBWUMsY0FBYyxHQUFHWCwrQ0FBUUEsQ0FBQztRQUFFWSxPQUFPO1FBQUdDLFFBQVE7SUFBRTtJQUVuRSxnQkFBZ0I7SUFDaEJmLGdEQUFTQSxDQUFDO1FBQ04sTUFBTWdCLGVBQWU7WUFDakIsSUFBSUwsYUFBYU0sT0FBTyxFQUFFO2dCQUN0QkosY0FBYztvQkFDVkMsT0FBT0gsYUFBYU0sT0FBTyxDQUFDQyxXQUFXO29CQUN2Q0gsUUFBUSxJQUFJLDZDQUE2QztnQkFDN0Q7WUFDSjtRQUNKO1FBRUEsZUFBZTtRQUNmQztRQUVBLHNCQUFzQjtRQUN0QkcsT0FBT0MsZ0JBQWdCLENBQUMsVUFBVUo7UUFDbEMsT0FBTyxJQUFNRyxPQUFPRSxtQkFBbUIsQ0FBQyxVQUFVTDtJQUN0RCxHQUFHLEVBQUU7SUFFTCxrREFBa0Q7SUFDbERoQixnREFBU0EsQ0FBQztRQUNOLElBQUksQ0FBQ1UsVUFBVU8sT0FBTyxJQUFJTCxXQUFX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O2dCQUNIZCxPQUFPO2dCQUNQQyxRQUFRO2dCQUNSdUYsVUFBVTtnQkFDVkMsS0FBSztnQkFDTEMsTUFBTTtZQUNWOzs7Ozs7Ozs7OztBQUloQjtHQTNQd0JyRztLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9PdmVybGFwQW5hbHlzaXMudHN4P2ZmNDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmludGVyZmFjZSBGdW5kIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBjb2xvcjogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgT3ZlcmxhcERhdGEge1xuICAgIGZ1bmRzOiB7IGlkOiBudW1iZXI7IG5hbWU6IHN0cmluZyB9W107XG4gICAgc3RvY2tzT3ZlcmxhcDogbnVtYmVyO1xuICAgIGF2ZXJhZ2VPdmVybGFwUGVyY2VudGFnZTogbnVtYmVyO1xuICAgIGNvbW1vblN0b2Nrczogc3RyaW5nW107XG59XG5cbmludGVyZmFjZSBGdW5kUGFpciB7XG4gICAgZnVuZDE6IG51bWJlcjtcbiAgICBmdW5kMjogbnVtYmVyO1xuICAgIGRhdGE6IE92ZXJsYXBEYXRhO1xufVxuXG5pbnRlcmZhY2UgT3ZlcmxhcEFuYWx5c2lzUHJvcHMge1xuICAgIGZ1bmRzPzogRnVuZFtdO1xuICAgIGNvbW1vblN0b2Nrcz86IHN0cmluZ1tdO1xuICAgIG92ZXJsYXBQYWlycz86IEZ1bmRQYWlyW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE92ZXJsYXBBbmFseXNpcyh7XG4gICAgZnVuZHMgPSBbXG4gICAgICAgIHsgaWQ6ICcxJywgbmFtZTogJ0F4aXMgQmx1ZWNoaXAgRnVuZCcsIGNvbG9yOiAnI0ZGRDcwMCcgfSxcbiAgICAgICAgeyBpZDogJzInLCBuYW1lOiAnSERGQyBUb3AgMTAwIEZ1bmQnLCBjb2xvcjogJyM0MTY5RTEnIH0sXG4gICAgICAgIHsgaWQ6ICczJywgbmFtZTogJ0lDSUNJIFBydWRlbnRpYWwgQmx1ZWNoaXAgRnVuZCcsIGNvbG9yOiAnIzMyQ0QzMicgfSxcbiAgICAgICAgeyBpZDogJzQnLCBuYW1lOiAnU0JJIEJsdWVjaGlwIEZ1bmQnLCBjb2xvcjogJyNGRjYzNDcnIH1cbiAgICBdLFxuICAgIGNvbW1vblN0b2NrcyA9IFtcbiAgICAgICAgJ0hERkMgTFRELicsXG4gICAgICAgICdSSUwnLFxuICAgICAgICAnSU5GWScsXG4gICAgICAgICdUQ1MnLFxuICAgICAgICAnSERGQ0JBTksnLFxuICAgICAgICAnQkhBUlRJQVJUTCdcbiAgICBdLFxuICAgIG92ZXJsYXBQYWlycyA9IFtdXG59OiBPdmVybGFwQW5hbHlzaXNQcm9wcykge1xuICAgIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XG4gICAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgICBjb25zdCBbY2FudmFzU2l6ZSwgc2V0Q2FudmFzU2l6ZV0gPSB1c2VTdGF0ZSh7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG5cbiAgICAvLyBIYW5kbGUgcmVzaXplXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0Q2FudmFzU2l6ZSh7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb250YWluZXJSZWYuY3VycmVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiA1MDAgLy8gSW5jcmVhc2VkIGhlaWdodCB0byBhY2NvbW1vZGF0ZSBtb3JlIGZ1bmRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW5pdGlhbCBzaXplXG4gICAgICAgIGhhbmRsZVJlc2l6ZSgpO1xuXG4gICAgICAgIC8vIEFkZCByZXNpemUgbGlzdGVuZXJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBEcmF3IHRoZSB2aXN1YWxpemF0aW9uIHdoZW4gY2FudmFzIHNpemUgY2hhbmdlc1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQgfHwgY2FudmFzU2l6ZS53aWR0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKCFjdHgpIHJldHVybjtcblxuICAgICAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnMgd2l0aCBkZXZpY2UgcGl4ZWwgcmF0aW8gZm9yIHNoYXJwZXIgcmVuZGVyaW5nXG4gICAgICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1NpemUud2lkdGggKiBkcHI7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNTaXplLmhlaWdodCAqIGRwcjtcblxuICAgICAgICAvLyBTY2FsZSBhbGwgZHJhd2luZyBvcGVyYXRpb25zXG4gICAgICAgIGN0eC5zY2FsZShkcHIsIGRwcik7XG5cbiAgICAgICAgLy8gU2V0IGRpc3BsYXkgc2l6ZVxuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtjYW52YXNTaXplLndpZHRofXB4YDtcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NhbnZhc1NpemUuaGVpZ2h0fXB4YDtcblxuICAgICAgICAvLyBDbGVhciBjYW52YXNcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXNTaXplLndpZHRoLCBjYW52YXNTaXplLmhlaWdodCk7XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgb3ZlcmxhcCB2aXN1YWxpemF0aW9uXG4gICAgICAgIGRyYXdPdmVybGFwVmlzdWFsaXphdGlvbihjdHgsIGNhbnZhc1NpemUud2lkdGgsIGNhbnZhc1NpemUuaGVpZ2h0LCBmdW5kcywgY29tbW9uU3RvY2tzLCBvdmVybGFwUGFpcnMpO1xuICAgIH0sIFtmdW5kcywgY29tbW9uU3RvY2tzLCBvdmVybGFwUGFpcnMsIGNhbnZhc1NpemVdKTtcblxuICAgIC8vIEZ1bmN0aW9uIHRvIGRyYXcgdGhlIG92ZXJsYXAgdmlzdWFsaXphdGlvblxuICAgIGNvbnN0IGRyYXdPdmVybGFwVmlzdWFsaXphdGlvbiA9IChcbiAgICAgICAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gICAgICAgIHdpZHRoOiBudW1iZXIsXG4gICAgICAgIGhlaWdodDogbnVtYmVyLFxuICAgICAgICBmdW5kczogRnVuZFtdLFxuICAgICAgICBjb21tb25TdG9ja3M6IHN0cmluZ1tdLFxuICAgICAgICBvdmVybGFwUGFpcnM6IEZ1bmRQYWlyW11cbiAgICApID0+IHtcbiAgICAgICAgLy8gQmFja2dyb3VuZCBmb3IgdGhlIHZpc3VhbGl6YXRpb24gYXJlYSAoZGFyayBncmF5KVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyMxYTFhMWEnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgLy8gRHJhdyBmdW5kcyBvbiB0aGUgbGVmdCBzaWRlXG4gICAgICAgIGNvbnN0IGZ1bmRCb3hIZWlnaHQgPSA1MDsgLy8gUmVkdWNlZCBoZWlnaHQgZm9yIGVhY2ggZnVuZCBib3hcbiAgICAgICAgY29uc3QgZnVuZEJveFdpZHRoID0gMTgwO1xuICAgICAgICBjb25zdCBmdW5kU3BhY2luZyA9IDMwOyAvLyBSZWR1Y2VkIHNwYWNpbmcgYmV0d2VlbiBmdW5kc1xuICAgICAgICBjb25zdCB0b3RhbEZ1bmRzSGVpZ2h0ID0gZnVuZHMubGVuZ3RoICogZnVuZEJveEhlaWdodCArIChmdW5kcy5sZW5ndGggLSAxKSAqIGZ1bmRTcGFjaW5nO1xuICAgICAgICBsZXQgZnVuZFN0YXJ0WSA9IChoZWlnaHQgLSB0b3RhbEZ1bmRzSGVpZ2h0KSAvIDI7XG5cbiAgICAgICAgY29uc3QgZnVuZFBvc2l0aW9uczogeyBba2V5OiBzdHJpbmddOiB7IHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9IH0gPSB7fTtcblxuICAgICAgICBmdW5kcy5mb3JFYWNoKChmdW5kLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeSA9IGZ1bmRTdGFydFkgKyBpbmRleCAqIChmdW5kQm94SGVpZ2h0ICsgZnVuZFNwYWNpbmcpO1xuXG4gICAgICAgICAgICAvLyBTdG9yZSBwb3NpdGlvbiBmb3IgbGF0ZXIgdXNlXG4gICAgICAgICAgICBmdW5kUG9zaXRpb25zW2Z1bmQuaWRdID0ge1xuICAgICAgICAgICAgICAgIHg6IDUwLCAvLyBNb3ZlZCBmdXJ0aGVyIGxlZnRcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBmdW5kQm94V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBmdW5kQm94SGVpZ2h0XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBEcmF3IGZ1bmQgYm94XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyMyYTJhMmEnO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJvdW5kUmVjdCg1MCwgeSwgZnVuZEJveFdpZHRoLCBmdW5kQm94SGVpZ2h0LCA4KTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgICAgIC8vIERyYXcgY29sb3JlZCBpbmRpY2F0b3IgYmFyIC0gbm93IG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBmdW5kIGJveFxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZ1bmQuY29sb3I7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoZnVuZEJveFdpZHRoICsgNTUsIHksIDUsIGZ1bmRCb3hIZWlnaHQpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IGZ1bmQgbmFtZVxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjRkZGRkZGJztcbiAgICAgICAgICAgIGN0eC5mb250ID0gJzEycHggQXJpYWwnO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXG4gICAgICAgICAgICAvLyBJbXByb3ZlZCB0ZXh0IHdyYXBwaW5nIHRvIGVuc3VyZSB0ZXh0IHN0YXlzIHdpdGhpbiB0aGUgZnVuZCBib3hcbiAgICAgICAgICAgIGNvbnN0IG1heFdpZHRoID0gZnVuZEJveFdpZHRoIC0gMjA7IC8vIExlYXZlIHNvbWUgcGFkZGluZ1xuICAgICAgICAgICAgY29uc3Qgd29yZHMgPSBmdW5kLm5hbWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRMaW5lID0gd29yZHNbMF07XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBsaW5lcyB0aGF0IGZpdCB3aXRoaW4gdGhlIGJveCB3aWR0aFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RMaW5lID0gY3VycmVudExpbmUgKyAnICcgKyB3b3Jkc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KHRlc3RMaW5lKTtcblxuICAgICAgICAgICAgICAgIGlmIChtZXRyaWNzLndpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChjdXJyZW50TGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gd29yZHNbaV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmUgPSB0ZXN0TGluZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTsgLy8gQWRkIHRoZSBsYXN0IGxpbmVcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHZlcnRpY2FsIHBvc2l0aW9uIGZvciB0ZXh0XG4gICAgICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gMTY7XG4gICAgICAgICAgICBjb25zdCB0b3RhbFRleHRIZWlnaHQgPSBsaW5lcy5sZW5ndGggKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgbGV0IHRleHRZID0geSArIChmdW5kQm94SGVpZ2h0IC0gdG90YWxUZXh0SGVpZ2h0KSAvIDIgKyBsaW5lSGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBEcmF3IGVhY2ggbGluZSBjZW50ZXJlZCBpbiB0aGUgYm94XG4gICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChsaW5lLCBmdW5kQm94V2lkdGggLyAyICsgNTAsIHRleHRZKTtcbiAgICAgICAgICAgICAgICB0ZXh0WSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERyYXcgc3RvY2tzIG9uIHRoZSByaWdodCBzaWRlXG4gICAgICAgIGNvbnN0IHN0b2NrQm94SGVpZ2h0ID0gMzA7XG4gICAgICAgIGNvbnN0IHN0b2NrU3BhY2luZyA9IDIwO1xuICAgICAgICBjb25zdCB0b3RhbFN0b2Nrc0hlaWdodCA9IGNvbW1vblN0b2Nrcy5sZW5ndGggKiBzdG9ja0JveEhlaWdodCArIChjb21tb25TdG9ja3MubGVuZ3RoIC0gMSkgKiBzdG9ja1NwYWNpbmc7XG4gICAgICAgIGxldCBzdG9ja1N0YXJ0WSA9IChoZWlnaHQgLSB0b3RhbFN0b2Nrc0hlaWdodCkgLyAyO1xuXG4gICAgICAgIGNvbnN0IHN0b2NrUG9zaXRpb25zOiB7IFtrZXk6IHN0cmluZ106IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSB9ID0ge307XG5cbiAgICAgICAgY29tbW9uU3RvY2tzLmZvckVhY2goKHN0b2NrLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeSA9IHN0b2NrU3RhcnRZICsgaW5kZXggKiAoc3RvY2tCb3hIZWlnaHQgKyBzdG9ja1NwYWNpbmcpO1xuXG4gICAgICAgICAgICAvLyBTdG9yZSBwb3NpdGlvbiBmb3IgbGF0ZXIgdXNlXG4gICAgICAgICAgICBzdG9ja1Bvc2l0aW9uc1tzdG9ja10gPSB7XG4gICAgICAgICAgICAgICAgeDogd2lkdGggLSAxMjAsIC8vIE1vdmVkIGZ1cnRoZXIgcmlnaHRcbiAgICAgICAgICAgICAgICB5OiB5ICsgc3RvY2tCb3hIZWlnaHQgLyAyXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBEcmF3IHN0b2NrIGxhYmVsXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNGRkZGRkYnO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSAnMTRweCBBcmlhbCc7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChzdG9jaywgd2lkdGggLSAyMCwgeSArIHN0b2NrQm94SGVpZ2h0IC8gMiArIDQpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHNtYWxsIHNxdWFyZSBpbmRpY2F0b3IgZm9yIGVhY2ggc3RvY2tcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnI0ZGRkZGRic7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3Qod2lkdGggLSAxMzAsIHkgKyBzdG9ja0JveEhlaWdodCAvIDIgLSAyLCA0LCA0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRHJhdyBjb25uZWN0aW9ucyBiZXR3ZWVuIGZ1bmRzIGFuZCBzdG9ja3NcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDEuNTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBtYXAgdG8gdHJhY2sgd2hpY2ggc3RvY2tzIGFyZSBjb21tb24gYmV0d2VlbiB3aGljaCBmdW5kc1xuICAgICAgICBjb25zdCBmdW5kU3RvY2tNYXA6IFJlY29yZDxzdHJpbmcsIFNldDxzdHJpbmc+PiA9IHt9O1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIG1hcCBmb3IgZWFjaCBmdW5kXG4gICAgICAgIGZ1bmRzLmZvckVhY2goZnVuZCA9PiB7XG4gICAgICAgICAgICBmdW5kU3RvY2tNYXBbZnVuZC5pZF0gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUG9wdWxhdGUgdGhlIG1hcCBiYXNlZCBvbiBvdmVybGFwIHBhaXJzXG4gICAgICAgIG92ZXJsYXBQYWlycy5mb3JFYWNoKHBhaXIgPT4ge1xuICAgICAgICAgICAgaWYgKHBhaXIuZGF0YSAmJiBwYWlyLmRhdGEuY29tbW9uU3RvY2tzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuZDFJZCA9IHBhaXIuZnVuZDEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5kMklkID0gcGFpci5mdW5kMi50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAgICAgcGFpci5kYXRhLmNvbW1vblN0b2Nrcy5mb3JFYWNoKHN0b2NrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmRTdG9ja01hcFtmdW5kMUlkXSkgZnVuZFN0b2NrTWFwW2Z1bmQxSWRdLmFkZChzdG9jayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5kU3RvY2tNYXBbZnVuZDJJZF0pIGZ1bmRTdG9ja01hcFtmdW5kMklkXS5hZGQoc3RvY2spO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGb3IgZWFjaCBmdW5kLCBjb25uZWN0IHRvIGl0cyBjb21tb24gc3RvY2tzXG4gICAgICAgIGZ1bmRzLmZvckVhY2goKGZ1bmQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bmRQb3MgPSBmdW5kUG9zaXRpb25zW2Z1bmQuaWRdO1xuICAgICAgICAgICAgY29uc3QgZnVuZENlbnRlclkgPSBmdW5kUG9zLnkgKyBmdW5kUG9zLmhlaWdodCAvIDI7XG4gICAgICAgICAgICBjb25zdCBmdW5kRW5kWCA9IGZ1bmRQb3MueCArIGZ1bmRQb3Mud2lkdGggKyA1OyAvLyBTdGFydCBmcm9tIHRoZSByaWdodCBlZGdlIG9mIHRoZSBmdW5kIGJveFxuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHN0b2NrcyBmb3IgdGhpcyBmdW5kXG4gICAgICAgICAgICBjb25zdCBzdG9ja3NGb3JGdW5kID0gZnVuZFN0b2NrTWFwW2Z1bmQuaWRdIHx8IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgICAgICAgICAvLyBEcmF3IGNvbm5lY3Rpb25zIG9ubHkgdG8gc3RvY2tzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhpcyBmdW5kXG4gICAgICAgICAgICBjb21tb25TdG9ja3MuZm9yRWFjaCgoc3RvY2spID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvY2tzRm9yRnVuZC5oYXMoc3RvY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0b2NrUG9zID0gc3RvY2tQb3NpdGlvbnNbc3RvY2tdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBncmFkaWVudCBmb3IgdGhlIGN1cnZlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KGZ1bmRFbmRYLCBmdW5kQ2VudGVyWSwgc3RvY2tQb3MueCwgc3RvY2tQb3MueSk7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBmdW5kLmNvbG9yICsgJzgwJyk7IC8vIDUwJSBvcGFjaXR5IGF0IHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBmdW5kLmNvbG9yICsgJzQwJyk7IC8vIDI1JSBvcGFjaXR5IGF0IGVuZFxuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGdyYWRpZW50O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERyYXcgdGhlIGN1cnZlXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhmdW5kRW5kWCwgZnVuZENlbnRlclkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRyb2wgcG9pbnRzIGZvciB0aGUgYmV6aWVyIGN1cnZlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNwMXggPSBmdW5kRW5kWCArIChzdG9ja1Bvcy54IC0gZnVuZEVuZFgpICogMC40O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjcDF5ID0gZnVuZENlbnRlclk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNwMnggPSBmdW5kRW5kWCArIChzdG9ja1Bvcy54IC0gZnVuZEVuZFgpICogMC42O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjcDJ5ID0gc3RvY2tQb3MueTtcblxuICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCBzdG9ja1Bvcy54LCBzdG9ja1Bvcy55KTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiByZWY9e2NvbnRhaW5lclJlZn0gY2xhc3NOYW1lPVwicmVsYXRpdmUgaC1bNTAwcHhdIHctZnVsbFwiPlxuICAgICAgICAgICAgPGNhbnZhc1xuICAgICAgICAgICAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIk92ZXJsYXBBbmFseXNpcyIsImZ1bmRzIiwiaWQiLCJuYW1lIiwiY29sb3IiLCJjb21tb25TdG9ja3MiLCJvdmVybGFwUGFpcnMiLCJjYW52YXNSZWYiLCJjb250YWluZXJSZWYiLCJjYW52YXNTaXplIiwic2V0Q2FudmFzU2l6ZSIsIndpZHRoIiwiaGVpZ2h0IiwiaGFuZGxlUmVzaXplIiwiY3VycmVudCIsIm9mZnNldFdpZHRoIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHByIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNjYWxlIiwic3R5bGUiLCJjbGVhclJlY3QiLCJkcmF3T3ZlcmxhcFZpc3VhbGl6YXRpb24iLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImZ1bmRCb3hIZWlnaHQiLCJmdW5kQm94V2lkdGgiLCJmdW5kU3BhY2luZyIsInRvdGFsRnVuZHNIZWlnaHQiLCJsZW5ndGgiLCJmdW5kU3RhcnRZIiwiZnVuZFBvc2l0aW9ucyIsImZvckVhY2giLCJmdW5kIiwiaW5kZXgiLCJ5IiwieCIsImJlZ2luUGF0aCIsInJvdW5kUmVjdCIsImZpbGwiLCJmb250IiwidGV4dEFsaWduIiwibWF4V2lkdGgiLCJ3b3JkcyIsInNwbGl0IiwibGluZXMiLCJjdXJyZW50TGluZSIsImkiLCJ0ZXN0TGluZSIsIm1ldHJpY3MiLCJtZWFzdXJlVGV4dCIsInB1c2giLCJsaW5lSGVpZ2h0IiwidG90YWxUZXh0SGVpZ2h0IiwidGV4dFkiLCJsaW5lIiwiZmlsbFRleHQiLCJzdG9ja0JveEhlaWdodCIsInN0b2NrU3BhY2luZyIsInRvdGFsU3RvY2tzSGVpZ2h0Iiwic3RvY2tTdGFydFkiLCJzdG9ja1Bvc2l0aW9ucyIsInN0b2NrIiwibGluZVdpZHRoIiwiZnVuZFN0b2NrTWFwIiwiU2V0IiwicGFpciIsImRhdGEiLCJmdW5kMUlkIiwiZnVuZDEiLCJ0b1N0cmluZyIsImZ1bmQySWQiLCJmdW5kMiIsImFkZCIsImZ1bmRQb3MiLCJmdW5kQ2VudGVyWSIsImZ1bmRFbmRYIiwic3RvY2tzRm9yRnVuZCIsImhhcyIsInN0b2NrUG9zIiwiZ3JhZGllbnQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsInN0cm9rZVN0eWxlIiwibW92ZVRvIiwiY3AxeCIsImNwMXkiLCJjcDJ4IiwiY3AyeSIsImJlemllckN1cnZlVG8iLCJzdHJva2UiLCJkaXYiLCJyZWYiLCJjbGFzc05hbWUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/OverlapAnalysis.tsx\n"));

/***/ })

});